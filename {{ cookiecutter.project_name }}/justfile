{% raw %}set dotenv-load := true

# List all available commands
_default:
    @just --list --unsorted

# ----------------------------------------------------------------------
# DEPENDENCIES
# ----------------------------------------------------------------------

# Bootstrap local development environment
@bootstrap:
    just install

# Setup local environnment
setup:
    #!/usr/bin/env bash
    [ ! -d .git ] && git init && git add -A
    just bootstrap
    uv run pre-commit install --install-hooks
    just migrate
    just createsuperuser
    just lint > /dev/null 2>&1 || true
    echo "DEBUG=True" >> .env

# Install dependencies
@install:
    uv sync

# Generate requirements.txt file
@lock *ARGS:
    uv pip compile pyproject.toml --output-file requirements.txt --generate-hashes {{ ARGS }}

# Generate and upgrade dependencies
@upgrade:
    uv sync --upgrade

# Clean up local development environment
@clean:
    rm -rf .venv
    rm -f .coverage.*

# ----------------------------------------------------------------------
# TESTING/TYPES
# ----------------------------------------------------------------------

# Run the test suite, generate code coverage, and export html report
@coverage-html: test
    rm -rf htmlcov
    @uv run python -m coverage html --skip-covered --skip-empty

# Run the test suite, generate code coverage, and print report to stdout
coverage-report: test
    @uv run python -m coverage report

# Run tests using pytest
@test *ARGS:
    uv run coverage run -m pytest {{ ARGS }}

# Run mypy on project
@types:
    uv run python -m mypy .

# Run the django deployment checks
@deploy-checks:
    just dj check --deploy

# ----------------------------------------------------------------------
# DJANGO
# ----------------------------------------------------------------------

# Run a django management command
@dj *COMMAND:
    uv run -m {% endraw %}{{ cookiecutter.project_name }}{% raw %} {{ COMMAND }}

# Run the django development server
@server ADDRESS="":
    just dj work {{ ADDRESS }}

# Kill the django development server in case the process is running in the background
@kill-server PORT="8000":
    lsof -i :{{ PORT }} -sTCP:LISTEN -t | xargs -t kill

# Open a Django shell using django-extensions shell_plus command
@shell:
    just dj shell_plus

alias mm := makemigrations

# Generate Django migrations
@makemigrations *APPS:
    just dj makemigrations {{ APPS }}

# Run Django migrations
@migrate *ARGS:
    just dj migrate {{ ARGS }}

# Reset the database
@reset-db:
    just dj reset_db --noinput

alias su := createsuperuser

# Quickly create a superuser with the provided credentials
createsuperuser EMAIL="admin@localhost" PASSWORD="admin":
    #!/usr/bin/env bash
    set -euo pipefail
    email="{{ EMAIL }}"
    export DJANGO_SUPERUSER_PASSWORD='{{ PASSWORD }}'
    export DJANGO_SUPERUSER_USERNAME="${email%%@*}"
    just dj createsuperuser --noinput --email "{{ EMAIL }}"

# Generate admin code for a django app
@admin APP:
    just dj admin_generator {{ APP }} | tail -n +2 > {% endraw %}{{ cookiecutter.project_name }}{% raw %}/{{ APP }}/admin.py

# Collect static files
@collectstatic:
    just dj tailwind --skip-checks build
    just dj collectstatic --no-input --skip-checks

# ----------------------------------------------------------------------
# DOCS
# ----------------------------------------------------------------------

# Build documentation using Sphinx
@docs-build LOCATION="docs/_build/html":
    uv run sphinx-build docs {{ LOCATION }}

# Serve documentation locally
@docs-serve:
    uv run sphinx-autobuild docs docs/_build/html --port 8001

# ----------------------------------------------------------------------
# LINTING / FORMATTING
# ----------------------------------------------------------------------

# Run all formatters
@fmt:
    just --fmt --unstable
    uv run pre-commit run pyproject-fmt -a > /dev/null 2>&1 || true
    uv run pre-commit run reorder-python-imports -a  > /dev/null 2>&1 || true
    uv run pre-commit run djade -a  > /dev/null 2>&1 || true

# Run pre-commit on all files
@lint:
    uv run pre-commit run --all-files

# ----------------------------------------------------------------------
# BUILD UTILITIES
# ----------------------------------------------------------------------

# Generate changelog
logchanges *ARGS:
    uv run git-cliff --output CHANGELOG.md {{ ARGS }}

# Bump project version and update changelog
bumpver VERSION:
    #!/usr/bin/env bash
    set -euo pipefail
    uv run bump-my-version bump {{ VERSION }}
    just logchanges
    [ -z "$(git status --porcelain)" ] && { echo "No changes to commit."; git push && git push --tags; exit 0; }
    version="$(uv run bump-my-version show current_version)"
    git add -A
    git commit -m "Generate changelog for version ${version}"
    git tag -f "v${version}"
    git push && git push --tags

# Build a binary distribution of the project using pyapp
build-bin:
    #!/usr/bin/env bash
    current_version=$(uv run bump-my-version show current_version)
    uv build
    export PYAPP_UV_ENABLED="1"
    export PYAPP_PYTHON_VERSION="3.12"
    export PYAPP_FULL_ISOLATION="1"
    export PYAPP_EXPOSE_METADATA="1"
    export PYAPP_PROJECT_NAME="{% endraw %}{{ cookiecutter.project_name }}{% raw %}"
    export PYAPP_PROJECT_VERSION="${current_version}"
    export PYAPP_PROJECT_PATH="${PWD}/dist/{% endraw %}{{ cookiecutter.project_name }}{% raw %}-${current_version}-py3-none-any.whl"
    export PYAPP_DISTRIBUTION_EMBED="1"
    export RUST_BACKTRACE="full"
    cargo install pyapp --force --root dist
    mv dist/bin/pyapp "dist/bin/{% endraw %}{{ cookiecutter.project_name }}{% raw %}-${current_version}"

# Build linux binary in docker
build-linux-bin:
    mkdir dist || true
    docker build -t build-bin-container . -f deploy/Dockerfile.binary
    docker run -it -v "${PWD}:/app" -w /app --name final-build build-bin-container uv build && just build-bin
    docker cp final-build:/app/dist .
    docker rm -f final-build

# Build docker image
build-docker-image:
    #!/usr/bin/env bash
    set -euo pipefail
    export DEBUG="False"
    current_version=$(uv run bump-my-version show current_version)
    image_name="{% endraw %}{{ cookiecutter.project_name }}{% raw %}"
    just install
    docker build -t "${image_name}:${current_version}" -f deploy/Dockerfile .
    docker tag "${image_name}:${current_version}" "${image_name}:latest"
    echo "Built docker image ${image_name}:${current_version}"
{% endraw %}
